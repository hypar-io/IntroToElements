#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!csharp

#r "nuget: Hypar.Elements, *-*"

#!markdown

# Elements + Models

We're almost done with the basics of Elements. We've covered points, lines, polylines, polygons, profiles, laminas, extrudes, sweeps, and transforms.

Now, we'll put it all together to create `Element`s and `Model`s, which will be the basis for the Hypar Functions we create and publish on Hypar.

All this time we've been working with _primitives_, rather than true elements. 

When you do `return` in a notebook, we render these primitives so you can see what's going on, but as we'll see later, if you try to output these in a model on Hypar, nothing will happen. To make something visible on Hypar, we need to create real `Element`s, which are flexible, customizable BIM entities, which can have visible geometry and other properties.

When you build a function, you will set a single `Model` as the output of that function, and add many `Element`s to it, with `Model.AddElement`.

#!csharp

// Create a model and add a mass.

#!csharp

// Add some floors.

#!csharp

// Create a column grid

#!markdown

These few built-in types have built-in ideas about how they look: they have default `Representation`s, and default `Material`s. 

A `Floor` creates an `Extrude`, and gets a `Concrete` material, and so on. 

Eventually we'll be defining our own element types, but for now we can also create elements with custom representations by using the generic `GeometricElement` class. Let's borrow some code from a previous chapter:

#!csharp

// Construct a representation from various solid operations

#!csharp

// Create some elements with that representation.

#!markdown

To draw curves as elements, you can use the `ModelCurve` class. In fact, this is what has been happening under the hood when you `return` a curve directly in a notebook â€” we just automatically create a `ModelCurve` from it for you.

#!csharp

// Create ModelCurves
